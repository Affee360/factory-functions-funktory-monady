import {
  CodeSurfer,
  CodeSurferColumns,
  Step,
} from "code-surfer";
import {
  github,
  vsDark,
  nightOwl,
} from "@code-surfer/themes";
import { Image, Head } from "mdx-deck";

export const theme = nightOwl;

<Head>
  <title>Factory Functions, functor, monad</title>
  <link rel="icon" type="image/x-icon" href="https://raw.githubusercontent.com/Affee360/factory-functions-funktory-monady/master/images/favicon.ico" />
</Head>

# Cześć 👋

<p style="text-align: center">
  Programowanie funkcyjne w JavaScript, czyli czym są
  Factory Functions, funktory i monady.
</p>

---

# O mnie

* Ernest Teluk
* FullStack developer
* MERN Stack + typescript
* Lubie grać na perkusji
* Mam Kota Gibcia ❤️

---

<CodeSurferColumns theme={theme}>

<Step>

```js showNumbers
class PieceOfCake {
  bake() {}
  decorate() {}
  cut() {}
}
```

</Step>

<Step>

```js showNumbers
class PieceOfCake {
  bake() {}
  decorate() {}
  cut() {}
}

class Muffin {
  bake() {}
  decorate() {}
  heatUp() {}
}
```

</Step>

<Step>

```js title="Przydało by się użyć zasady Don't Repeat Yourself" showNumbers 1:11
class PieceOfCake {
  bake() {}
  decorate() {}
  cut() {}
}

class Muffin {
  bake() {}
  decorate() {}
  heatUp() {}
}
```

</Step>

<Step>

```js showNumbers 1:4
class Baking {
  bake() {}
  decorate() {}
}
```

</Step>

<Step>

```js title="inheritance" showNumbers
class Baking {
  bake() {}
  decorate() {}
}

class PieceOfCake extends Baking {
  cut() {}
}

class Muffin extends Baking {
  heatUp() {}
}
```

</Step>

<Step>

```js showNumbers
class Baking {
  bake() {}
  decorate() {}
}

class PieceOfCake extends Baking {
  cut() {}
}

class Muffin extends Baking {
  heatUp() {}
}

class Salad {
  mixed() {}
  decorate() {}
}
```

</Step>

<Step>

```js title="The Duplication by Necessity Problem" showNumbers 1:17
class Baking {
  bake() {}
  decorate() {}
}

class PieceOfCake extends Baking {
  cut() {}
}

class Muffin extends Baking {
  heatUp() {}
}

class Salad {
  mixed() {}
  decorate() {}
}
```

</Step>

</CodeSurferColumns>

---

# Factory Function

<p style="text-align: center">Factory function to dowolna funkcja, która nie jest klasą ani konstruktorem, która zwraca (prawdopodobnie nowy) obiekt</p>

---

<CodeSurferColumns theme={theme}>

<Step>

```js title="Composition" showNumbers
const bakable = (state) => ({
  bake: () => console.log(`baking new ${state.type}`),
});

const decorable = (state) => ({
  decorate: () => console.log(`decorating new ${state.name}`),
});

const cutable = (state) => ({
  cut: () => console.log(`cuting new ${state.name}`),
});
```

</Step>

<Step>

```js title="Factory Function" showNumbers
const bakable = (state) => ({
  bake: () => console.log(`baking new ${state.type}`),
});

const decorable = (state) => ({
  decorate: () => console.log(`decorating new ${state.name}`),
});

const cutable = (state) => ({
  cut: () => console.log(`cuting new ${state.name}`),
});

const pieceOfCake = (name, type) => {
  const state = { name, type };

  return Object.assign({}, bakable(state), decorable(state), cutable(state));
};
```

</Step>

<Step>

```js title="Factory Function" showNumbers
const bakable = (state) => ({
  bake: () => console.log(`baking new ${state.type}`),
});

const decorable = (state) => ({
  decorate: () => console.log(`decorating new ${state.name}`),
});

const cutable = (state) => ({
  cut: () => console.log(`cuting new ${state.name}`),
});

const pieceOfCake = (name, type) => {
  const state = { name, type };

  return Object.assign({}, bakable(state), decorable(state), cutable(state));
};

const newPiece = pieceOfCake('chocolate cake', 'cake');
newPiece.bake();
newPiece.decorate();
newPiece.cut();
```

</Step>

</CodeSurferColumns>

---

<Image
  src="https://raw.githubusercontent.com/Affee360/factory-functions-funktory-monady/master/images/1.png"
  style="background-image: contain; background-size: 800px auto;"
/>

---

<CodeSurferColumns theme={theme}>

<Step>

```js showNumbers
class List {
  items = []
}
```

</Step>

<Step>

```js showNumbers
class List {
  items = []

  addItem(item) {
    this.items.push(item)
  }
}
```

</Step>

<Step>

```js showNumbers
class List {
  items = []

  addItem(item) {
    this.items.push(item)
  }

  getItems() {
    return this.items;
  }
}
```

</Step>

<Step>

```js showNumbers
class List {
  items = []

  addItem(item) {
    this.items.push(item)
  }

  getItems() {
    return this.items;
  }
}

const numbers = new List()
```

</Step>

<Step>

```js showNumbers
class List {
  items = []

  addItem(item) {
    this.items.push(item)
  }

  getItems() {
    return this.items;
  }
}

const numbers = new List()
numbers.addItem(1);
numbers.addItem(2);
numbers.getItems();
```

</Step>

<Step>

```js showNumbers
class List {
  items = []

  addItem(item) {
    this.items.push(item)
  }

  getItems() {
    return this.items;
  }
}

const numbers = new List()
numbers.addItem(1);
numbers.addItem(2);
numbers.getItems();
numbers.items;
```

</Step>

<Step>

```js showNumbers
class List {
  items = []

  addItem(item) {
    this.items.push(item)
  }

  getItems() {
    return this.items;
  }
}

const numbers = new List()
numbers.addItem(1);
numbers.addItem(2);
numbers.getItems();
numbers.items;

const button = document.querySelector('button');
button.addEventListener('click', numbers.getItems) // undefined
button.addEventListener('click', numbers.getItems.bind(this)) // [1,2]
```

</Step>

</CodeSurferColumns>

---

# Wady

* Brak możliwości enkapsulacji
* Problematyczne słowo kluczowe this

---

<CodeSurferColumns theme={theme}>

<Step>

```js showNumbers
const list = () => {
  const items = [];
}
```

</Step>

<Step>

```js showNumbers
const list = () => {
  const items = [];

  return { 
    addItem: (item) => items.push(item),
    getItems: () => items,
  }
}
```

</Step>

<Step>

```js showNumbers
const list = () => {
  const items = [];

  return { 
    addItem: (item) => items.push(item),
    getItems: () => items,
  }
}

const numbers = list();
numbers.addItem(1);
numbers.addItem(2);
numbers.getItems(); // [1,2]
numbers.items; // undefined
```

</Step>

<Step>

```js showNumbers
const list = () => {
  const items = [];

  return { 
    addItem: (item) => items.push(item),
    getItems: () => items,
  }
}

const numbers = list();
numbers.addItem(1);
numbers.addItem(2);
numbers.getItems(); // [1,2]
numbers.items; // undefined
numbers.addItem = '';
numbers.addItem(3) // numbers.addItem is not a function
```

</Step>

<Step>

```js showNumbers
const list = () => {
  const items = [];

  return Object.freeze({ 
    addItem: (item) => items.push(item),
    getItems: () => items,
  })
}

const numbers = list();
numbers.addItem(1);
numbers.addItem(2);
numbers.getItems(); // [1,2]
numbers.items; // undefined
numbers.addItem = '';
numbers.addItem(3)
numbers.getItems() // [1,2,3]
```

</Step>

</CodeSurferColumns>

---

# Orientuj

<p style="text-align: center">Ze względu na zbieżność <mark>przedstawianej koncepcji</mark> z metodami tablicy w <mark>vanila js</mark> przedstawię porównanie funkcji <strong>map</strong> oraz <strong>flatMap</strong></p>

---

# Map

<p style="text-align: center">W vanila js na <mark>typie Array</mark> można wywołać funkcję <strong>.map</strong> , w konsekwencji otrzymując ponownie <mark>typ Array</mark> z nową zawartością.</p>

---

<h1 style="text-align: center">Mocna analogia w przypadku funktorów:</h1>

<p style="text-align: center">W omawianej koncepcji w <mark>funktorze X</mark> można wywołać funkcję <strong>.map</strong> , w konsekwencji otrzymując ponownie instancje <mark>funktora X</mark> z nową zawartością.</p>

--- 

# flatMap w vanila js

<p style="text-align: center">W vanila js na <mark>typie Array</mark> można wywołać funkcję <strong>.flatMap</strong> , w konsekwencji otrzymując <mark>tablicę</mark> z której każdy element uległ spłaszczeniu; poddaną spłaszczeniu.</p>

---

<CodeSurfer theme={theme}>

```js  showNumbers
  Array.prototype.flatMap = function(callback = () => {}) {
    return this.map(item => callback(item).flat()).flat()
  }
```

</CodeSurfer>

<p style="text-align: center">Ważne jest że znów otrzymujemy <mark>typ Array</mark> , który ma te same metody.</p>

---

# flatMap w funktorach

<p style="text-align: center">W omawianej koncepcji w <mark>funktorze X</mark> można wywołać funkcję <strong>.flatMap</strong> , co spowoduje zamknięcie literału, więc w konsekwencji otrzymamy <mark>typ prostszy.</mark></p>

<p style="text-align: center">Na takim wyniku nie możemy już wywoływać metod danego funktora.</p>

---

# Object in context

* Array(a)
* Observable(b)
* Promise(c)

--- 

# Funktory

<p style="text-align: center">
  Struktura danych, na której możesz mapować funkcje w celu pobrania wartości z kontenera, ich modyfikacji, a następnie włożenia z powrotem do kontenera.
</p>

---

<CodeSurferColumns theme={theme}>

<Step>

  ```js title="functor" showNumbers
  const array = [1,2,3,4];
  ```

</Step>

<Step>

  ```js title="functor" showNumbers
  const array = [1,2,3,4];
  const addOne = (value) => value + 1;
  ```

</Step>

<Step>

  ```js title="functor" showNumbers
  const array = [1,2,3,4];
  const addOne = (value) => value + 1;
  const arrayMap = array.map(addOne);
  ```

</Step>

</CodeSurferColumns>

---

# #1 Indentity

---

<CodeSurfer theme={theme}>

```js showNumbers
  const sameArray = array.map((v) => v);
  ```

</CodeSurfer>

---

# #2 Composition

---

<CodeSurferColumns theme={theme}>

<Step>

```js showNumbers
  const double = (value) => value * 2;
  const triple = (value) => value * 3;
  ```

</Step>

<Step>

 ```js showNumbers
  const double = (value) => value * 2;
  const triple = (value) => value * 3;

  const composition = array.map((v) => triple(double(v)));
  ```

</Step>

<Step>

 ```js showNumbers
  const double = (value) => value * 2;
  const triple = (value) => value * 3;

  const composition = array.map((v) => triple(double(v)));
  const chaining = array.map((v) => double(v)).map((v) => triple(v));
  ```

</Step>

</CodeSurferColumns>

---

<Image
  src="https://raw.githubusercontent.com/Affee360/factory-functions-funktory-monady/master/images/2.png"
  style="background-image: contain; background-size: 800px auto;"
/>

---

# Jak stworzyć functor

---

<CodeSurferColumns theme={theme}>

<Step>

```js showNumbers
  const double = (value) => value * 2;
  const triple = (value) => value * 3;
  ```

</Step>

<Step>

```js showNumbers
  const double = (value) => value * 2;
  const triple = (value) => value * 3;

  const functor = (v) => ({})
  ```

</Step>

<Step>

```js showNumbers
  const double = (value) => value * 2;
  const triple = (value) => value * 3;

  const functor = (v) => ({
    map: (fn) => functor(fn(v)),
  })
  ```

</Step>

<Step>

```js showNumbers
  const double = (value) => value * 2;
  const triple = (value) => value * 3;

  const functor = (v) => ({
    map: (fn) => functor(fn(v)),
    valueOf: () => v,
  })
  ```

</Step>

<Step>

```js showNumbers
  const double = (value) => value * 2;
  const triple = (value) => value * 3;

  const functor = (v) => ({
    map: (fn) => functor(fn(v)),
    valueOf: () => v,
  })

  const number = functor(2);
  ```

</Step>

<Step>

```js showNumbers
  const double = (value) => value * 2;
  const triple = (value) => value * 3;

  const functor = (v) => ({
    map: (fn) => functor(fn(v)),
    valueOf: () => v,
  })

  const number = functor(2);
  console.log("functor", number.map(double).map(triple).valueOf());
  ```

</Step>

</CodeSurferColumns>

---

<Image
  src="https://raw.githubusercontent.com/Affee360/factory-functions-funktory-monady/master/images/3.png"
  style="background-image: contain; background-size: 800px auto;"
/>

---

# Monada

<p style="text-align: center">
  Sposób komponowania funkcji, który oprócz wartości zwracanej wymagają kontekstu
</p>

--- 

<CodeSurferColumns theme={theme}>

<Step>

```js title="Przykłady monad" showNumbers 
  [1, 2, 3, 4].flatMap((v) => [v * 2])
  ```

</Step>

<Step>

```js title="Przykłady monad" showNumbers 
  [1, 2, 3, 4].flatMap((v) => [v * 2])

  const promise = new Promise((res) => setTimeout(() => res("done"), 500));
  ```

</Step>

<Step>

```js title="Przykłady monad" showNumbers 
  [1, 2, 3, 4].flatMap((v) => [v * 2])

  const promise = new Promise((res) => setTimeout(() => res("done"), 500));
  promise.then((data) => console.log(data));
  ```

</Step>

</CodeSurferColumns>

---

<h1 style="text-align: center">Jak w rzeczywistości działa promise</h1>

<CodeSurfer>

```js showNumbers
const promise = new Promise((res) => setTimeout(() => res("done"), 500));
promise.then((data) => console.log(data))
```

</CodeSurfer>

<p style="text-align: center">Promise(Promise('done')) w calbacku tych funkcji mamy dostęp do wartości</p>

---

<CodeSurfer>

```js showNumbers
const promise2 = promise.then((data) => data).then((data) => console.log(data));
console.log("this is promise", Object.prototype.toString.call(promise2));
```

</CodeSurfer>

<Image
  src="https://raw.githubusercontent.com/Affee360/factory-functions-funktory-monady/master/images/4.png"
  style="background-image: contain; background-size: 800px auto;"
/>

<p style="text-align: center">Promise(Promise('done')) -> Promise('done') = flat map</p>

---

# Przykład własnej monady

<p style="text-align: center">Funkcja do przeliczania stopni fahrenheita na celsjusza</p>

---

<CodeSurferColumns theme={theme}>

<Step>

```js showNumbers
const fahrenheitToCelcius = (a) => (a - 32) * 0.5556;
```

</Step>

<Step>

```js showNumbers
const fahrenheitToCelcius = (a) => (a - 32) * 0.5556;

const value1 = 15;
const value2 = null;
```

</Step>

<Step>

```js showNumbers
const fahrenheitToCelcius = (a) => (a - 32) * 0.5556;

const value1 = 15;
const value2 = null;

console.log("good", fahrenheitToCelcius(value1));
console.log("bad", fahrenheitToCelcius(value2));
```

</Step>

</CodeSurferColumns>

---

# Powstaje pewnien problem

<Image
  src="https://raw.githubusercontent.com/Affee360/factory-functions-funktory-monady/master/images/5.png"
  style="background-image: contain; background-size: 800px auto;"
/>

<p style="text-align: center">Wszystko dlatego że null jest zamieniany na 0</p>
<p style="text-align: center">Potrzebujemy czegoś co zatrzyma kompozycje jeśli wartość jest nullem</p>

---

<CodeSurferColumns theme={theme}>

<Step>

```js showNumbers
const just = (v) => ({
  map: (fn) => just(fn(v)),
  flatMap: (fn) => fn(v),
  valueOf: () => v,
  inspect: () => `just(${v})`,
  type: "just",
});
```

</Step>

<Step>

```js showNumbers
const just = (v) => ({
  map: (fn) => just(fn(v)),
  flatMap: (fn) => fn(x),
  valueOf: () => v,
  inspect: () => `just(${v})`,
  type: "just",
});

const nothing = () => ({
  map: (fn) => nothing(fn()),
  flatMap: (fn) => fn(),
  valueOf: () => nothing(),
  inspect: () => `nothing()`,
  type: "nothing",
});
```

</Step>

<Step>

```js showNumbers
const just = (v) => ({
  map: (fn) => just(fn(v)),
  flatMap: (fn) => fn(x),
  valueOf: () => v,
  inspect: () => `just(${v})`,
  type: "just",
});

const nothing = () => ({
  map: (fn) => nothing(fn()),
  flatMap: (fn) => fn(),
  valueOf: () => nothing(),
  inspect: () => `nothing()`,
  type: "nothing",
});

const maybeOf = (x) => (x == null || x.type === "nothing" ? nothing() : just(x));
```

</Step>

<Step>

```js showNumbers
const just = (v) => ({
  map: (fn) => just(fn(v)),
  flatMap: (fn) => fn(x),
  valueOf: () => v,
  inspect: () => `just(${v})`,
  type: "just",
});

const nothing = () => ({
  map: (fn) => nothing(fn()),
  flatMap: (fn) => fn(),
  valueOf: () => nothing(),
  inspect: () => `nothing()`,
  type: "nothing",
});

const maybeOf = (x) => (!x || x.type === "nothing" ? nothing() : just(x));

const maybe = {
  of: maybeOf,
};
```

</Step>

<Step>

```js showNumbers
const just = (v) => ({
  map: (fn) => just(fn(v)),
  flatMap: (fn) => fn(x),
  valueOf: () => v,
  inspect: () => `just(${v})`,
  type: "just",
});

const nothing = () => ({
  map: (fn) => nothing(fn()),
  flatMap: (fn) => fn(),
  valueOf: () => nothing(),
  inspect: () => `nothing()`,
  type: "nothing",
});

const maybeOf = (x) => (!x || x.type === "nothing" ? nothing() : just(x));

const maybe = {
  of: maybeOf,
};

const temp1 = maybe.of(value1).map(fahrenheitToCelcius).inspect();
const temp2 = maybe.of(value2).map(fahrenheitToCelcius).map(double).inspect();
console.log(temp1);
console.log(temp2);
```

</Step>

</CodeSurferColumns>

---

# Teraz oba wyniki są poprawne

<Image
  src="https://raw.githubusercontent.com/Affee360/factory-functions-funktory-monady/master/images/6.png"
  style="background-image: contain; background-size: 800px auto;"
/>

---

# Pytania ? 😀